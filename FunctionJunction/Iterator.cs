using System.Collections;

namespace FunctionJunction;

/// <summary>
/// Provides methods for creating infinite iterators that generate sequences of values using seed values and transformation functions.
/// These iterators can produce potentially infinite sequences, making them useful for mathematical sequences, state machines, and other iterative computations.
/// </summary>
public static class Iterator
{
    /// <summary>
    /// Creates an infinite <see cref="IEnumerable{T}"/> that generates values by starting with a seed and repeatedly applying a transformation function.
    /// The sequence begins with the value provided by the seed provider, then each subsequent value is produced by applying the iterator function to the previous value.
    /// This creates an infinite sequence, so consumers should use operations like <c>Take</c> to limit the number of elements.
    /// </summary>
    /// <typeparam name="T">The type of values in the sequence.</typeparam>
    /// <param name="seedProvider">A function that provides the initial value for the sequence.</param>
    /// <param name="iterator">A function that transforms each value to produce the next value in the sequence.</param>
    /// <returns>An infinite <see cref="IEnumerable{T}"/> of values generated by the iteration.</returns>
    /// <remarks>
    /// <code>
    /// // Generate powers of 2: 1, 2, 4, 8, 16, ...
    /// var powersOfTwo = Iterator.Iterate(() => 1, x => x * 2).Take(5);
    /// </code>
    /// </remarks>
    public static IEnumerable<T> Iterate<T>(Func<T> seedProvider, Func<T, T> iterator) => 
        new FunctionEnumerable<T>(() => new IteratorEnumerator<T>(seedProvider, iterator));

    /// <summary>
    /// Creates an infinite <see cref="IAsyncEnumerable{T}"/> that asynchronously generates values by starting with a seed and repeatedly applying an async transformation function.
    /// The sequence begins with the value provided by the async seed provider, then each subsequent value is produced by applying the async iterator function to the previous value.
    /// This creates an infinite sequence, so consumers should use operations like <c>Take</c> to limit the number of elements.
    /// </summary>
    /// <typeparam name="T">The type of values in the sequence.</typeparam>
    /// <param name="seedProviderAsync">An async function that provides the initial value for the sequence.</param>
    /// <param name="iteratorAsync">An async function that transforms each value to produce the next value in the sequence.</param>
    /// <returns>An infinite <see cref="IAsyncEnumerable{T}"/> of values generated by the async iteration.</returns>
    /// <remarks>
    /// <code>
    /// // Generate async sequence: 1, 3, 9, 27, 81, ...
    /// var powersOfThree = Iterator.Iterate(async () => 1, async x => await SomeAsyncOperation(x * 3));
    /// </code>
    /// </remarks>
    public static IAsyncEnumerable<T> Iterate<T>(Func<Task<T>> seedProviderAsync, Func<T, Task<T>> iteratorAsync) => 
        new FunctionEnumerableAsync<T>(cancellationToken => new IteratorAsyncEnumerator<T>(seedProviderAsync, iteratorAsync, cancellationToken));

    private class FunctionEnumerable<T>(Func<IEnumerator<T>> enumeratorProvider) : IEnumerable<T>
    {
        public IEnumerator<T> GetEnumerator() => enumeratorProvider();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    private class FunctionEnumerableAsync<T>(Func<CancellationToken, IAsyncEnumerator<T>> asyncEnumeratorProvider) : IAsyncEnumerable<T>
    {
        public IAsyncEnumerator<T> GetAsyncEnumerator(CancellationToken cancellationToken = default) => 
            asyncEnumeratorProvider(cancellationToken);
    }

    private class IteratorAsyncEnumerator<T>(Func<Task<T>> seedProviderAsync, Func<T, Task<T>> iteratorAsync, CancellationToken cancellationToken) : IAsyncEnumerator<T>
    {
        public T Current { get; private set; } = default!;

        private bool isMoved = false;

        public async ValueTask<bool> MoveNextAsync()
        {
            cancellationToken.ThrowIfCancellationRequested();

            Current = isMoved switch
            {
                true => await iteratorAsync(Current),
                false => await seedProviderAsync()
            };

            isMoved = true;
            return true;
        }

        public ValueTask DisposeAsync() => new();
    }

    private class IteratorEnumerator<T>(Func<T> seedProvider, Func<T, T> iterator) : IEnumerator<T>
    {
        public T Current { get; private set; } = default!;

        private bool isMoved = false;

        object IEnumerator.Current => Current!;

        public void Dispose() { }

        public bool MoveNext()
        {
            Current = isMoved switch
            {
                true => iterator(Current),
                false => seedProvider()
            };

            isMoved = true;
            return true;
        }

        public void Reset() => throw new NotSupportedException();
    }
}

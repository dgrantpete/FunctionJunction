namespace FunctionJunction;

/// <summary>
/// Provides methods for creating sequences from functions.
/// These can produce potentially infinite sequences, making them useful for mathematical sequences, state machines, and other iterative computations.
/// </summary>
public static class Iterator
{
    /// <summary>
    /// Creates an infinite <see cref="IEnumerable{T}"/> that generates values by starting with a seed value and repeatedly applying a transformation function.
    /// The sequence begins with the provided seed value, then each subsequent value is produced by applying the iterator function to the previous value.
    /// This creates an infinite sequence, so consumers should use operations like <c>Take</c> to limit the number of elements.
    /// </summary>
    /// <typeparam name="T">The type of values in the sequence.</typeparam>
    /// <param name="seed">The initial value for the sequence.</param>
    /// <param name="iterator">A function that transforms each value to produce the next value in the sequence.</param>
    /// <returns>An infinite <see cref="IEnumerable{T}"/> of values generated by the iteration.</returns>
    /// <remarks>
    /// <code>
    /// // Generate powers of 2: 1, 2, 4, 8, 16, ...
    /// var powersOfTwo = Iterator.Iterate(1, parent => parent * 2).Take(5);
    /// </code>
    /// </remarks>
    public static IEnumerable<T> Iterate<T>(T seed, Func<T, T> iterator)
    {
        var currentValue = seed;

        while (true)
        {
            yield return currentValue;
            currentValue = iterator(currentValue);
        }
    }

    /// <summary>
    /// Creates an infinite <see cref="IAsyncEnumerable{T}"/> that asynchronously generates values by starting with a seed value and repeatedly applying an async transformation function.
    /// The sequence begins with the provided seed value, then each subsequent value is produced by applying the async iterator function to the previous value.
    /// This creates an infinite sequence, so consumers should use operations like <c>Take</c> to limit the number of elements.
    /// </summary>
    /// <typeparam name="T">The type of values in the sequence.</typeparam>
    /// <param name="seed">The initial value for the sequence.</param>
    /// <param name="iteratorAsync">An async function that transforms each value to produce the next value in the sequence.</param>
    /// <returns>An infinite <see cref="IAsyncEnumerable{T}"/> of values generated by the async iteration.</returns>
    /// <remarks>
    /// <code>
    /// // Generate async sequence: 1, 3, 9, 27, 81, ...
    /// var powersOfThree = Iterator.Iterate(1, async parent => await SomeAsyncOperation(parent * 3));
    /// </code>
    /// </remarks>
    public static async IAsyncEnumerable<T> Iterate<T>(T seed, Func<T, ValueTask<T>> iteratorAsync)
    {
        var currentValue = seed;

        while (true)
        {
            yield return currentValue;
            currentValue = await iteratorAsync(currentValue).ConfigureAwait(false);
        }
    }


    /// <summary>
    /// Creates an <see cref="IterateManyEnumerable{T}"/> that generates a hierarchical sequence by starting with a seed value and repeatedly applying a function that returns multiple values.
    /// This is useful for traversing tree-like structures or creating hierarchical sequences where each element can produce multiple children.
    /// </summary>
    /// <typeparam name="T">The type of elements in the sequence.</typeparam>
    /// <param name="seed">The initial value for the sequence.</param>
    /// <param name="iterator">A function that takes a value and returns an enumerable of child values.</param>
    /// <returns>An <see cref="IterateManyEnumerable{T}"/> that can be configured for different traversal strategies.</returns>
    /// <remarks>
    /// <code>
    /// // Generate a tree structure where each number generates its factors
    /// var treeSequence = Iterator.IterateMany(12, n => n > 1 ? GetFactors(n) : Enumerable.Empty&lt;int&gt;());
    /// </code>
    /// </remarks>
    public static IterateManyEnumerable<T> IterateMany<T>(T seed, Func<T, IEnumerable<T>> iterator) =>
        new(seed, iterator);

    public static IEnumerable<T> Generate<T>(Func<T> generator)
    {
        while (true)
        {
            yield return generator();
        }
    }

    public static async IAsyncEnumerable<T> Generate<T>(Func<ValueTask<T>> generatorAsync)
    {
        while (true)
        {
            yield return await generatorAsync().ConfigureAwait(false);
        }
    }
}

<!--
GENERATED FILE - DO NOT EDIT
This file was generated by [MarkdownSnippets](https://github.com/SimonCropp/MarkdownSnippets).
Source File: /README.source.md
To change this file edit the source file and then run MarkdownSnippets.
-->

# FunctionJunction

[![NuGet](https://img.shields.io/nuget/v/FunctionJunction.svg)](https://www.nuget.org/packages/FunctionJunction/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![.NET](https://img.shields.io/badge/.NET-netstandard2.0%20%7C%20net8.0%20%7C%20net9.0-512BD4)](https://dotnet.microsoft.com/)

![Logo](https://raw.githubusercontent.com/dgrantpete/FunctionJunction/refs/heads/main/FunctionJunction.png)

**Opinionated functional helpers for C# that keep your railway-oriented code on track.**

FunctionJunction is a comprehensive functional programming library for C# that provides Option and Result types, discriminated unions, and functional combinators with full async support. Built with modern C# in mind, it leverages source generators for compile-time safety and zero-overhead abstractions.

## Features

- **Option\<T\>** - Represent optional values without null reference exceptions
- **Result\<TOk, TError\>** - Railway-oriented programming for elegant error handling
- **Discriminated Unions** - Type-safe sum types with pattern matching via source generation
- **Comprehensive Async Support** - All operations have async counterparts with `Await` prefix
- **Iterator Extensions** - Functional LINQ extensions like `SelectWhere`, `Scan`, and `Enumerate`
- **AOT Compatible** - Works with Native AOT on .NET 7+ for maximum performance
- **Zero Overhead** - Source generators provide compile-time code generation with no runtime cost
- **Railway-Oriented Programming** - Chain operations that can fail gracefully

## Installation

```bash
dotnet add package FunctionJunction
```

## Target Frameworks

- .NET Standard 2.0 (broad compatibility)
- .NET 8.0
- .NET 9.0
- Native AOT compatible on .NET 7+

## Core Types

### Option<T>

Represents a value that may or may not exist.

#### Creating

<!-- snippet: OptionInstantiation -->
<a id='snippet-OptionInstantiation'></a>
```cs
// Implicitly created
Option<int> implicitSome = 10;
Option<int> implicitNone = default;

// Explicitly created
var explicitSome = Option.Some("Foo");
var explicitNone = Option.None<string>();

// From nullable value types
double? definitelyForSureNotNull = null;
var valueOption = Option.FromNullable(definitelyForSureNotNull);

// Nullable reference types can be converted implicitly
string? nullableReference = "Not null";
Option<string> referenceOption = nullableReference;
```
<sup><a href='/FunctionJunction.Tests/Examples/OptionExamples.cs#L8-L24' title='Snippet source file'>snippet source</a> | <a href='#snippet-OptionInstantiation' title='Start of snippet'>anchor</a></sup>
<!-- endSnippet -->

### Result<TOk, TError>

Represents an operation that can succeed with TOk or fail with TError.

```csharp
// Create results
Result<int, string> success = 42;  // Implicit conversion
Result<int, string> failure = "Error occurred";

// Transform and validate
var result = ParseInt(userInput)
    .Map(x => x * 2)
    .Validate(x => x > 0, _ => "Value must be positive")
    .MapError(error => $"Validation failed: {error}");

// Error recovery
var recovered = result
    .Recover(TryAlternativeMethod)
    .UnwrapOr(error => DefaultValue);
```

### Discriminated Unions

Create sum types with automatic pattern matching via source generation.

```csharp
[DiscriminatedUnion]
public partial record PaymentResult
{
    public record Success(string TransactionId, decimal Amount) : PaymentResult;
    public record Declined(string Reason) : PaymentResult;
    public record Error(Exception Exception) : PaymentResult;
}

// Generated Match method
var message = paymentResult.Match(
    onSuccess: (id, amount) => $"Payment ${amount} succeeded: {id}",
    onDeclined: reason => $"Payment declined: {reason}",
    onError: ex => $"Payment failed: {ex.Message}"
);
```

## Async Support

All operations have async counterparts that work with Task-returning functions with `Await` prefix:

```csharp
// Async operations
var userData = await userIdOption
    .FlatMap(FetchUserAsync)
    .AwaitFilter(user => user.IsActive)
    .AwaitMap(EnrichUserData)
    .AwaitUnwrapOr(GetDefaultUser);

// Combining multiple async operations
var result = await Result.All(
    () => ValidateEmail(email),
    () => CheckUserExists(email),
    () => VerifyNotBlacklisted(email)
);

// Async enumerable extensions
await productsIds
    .ToAsyncEnumerable()
    .SelectWhere(async id => await TryLoadProduct(id))
    .Scan(0m, (total, product) => total + product.Price)
    .Last();
```

## API Reference

### Option<T> Methods

- `Map<TResult>(Func<T, TResult>)` - Transform the value if present
- `FlatMap<TResult>(Func<T, Option<TResult>>)` - Chain operations that return Options
- `Filter(Func<T, bool>)` - Keep value only if predicate returns true
- `Or(Func<Option<T>>)` - Provide alternative if None
- `And<TOther>(Func<Option<TOther>>)` - Combine two Options into tuple
- `UnwrapOr(Func<T>)` - Extract value or provide default
- `UnwrapOrThrow<TException>(Func<TException>)` - Extract value or throw
- `TryUnwrap(out T?)` - Try pattern for safe extraction

### Result<TOk, TError> Methods

- `Map<TResult>(Func<TOk, TResult>)` - Transform success value
- `MapError<TResult>(Func<TError, TResult>)` - Transform error value
- `FlatMap<TResult>(Func<TOk, Result<TResult, TError>>)` - Chain operations
- `Recover<TResult>(Func<TError, Result<TOk, TResult>>)` - Attempt error recovery
- `Validate(Func<TOk, bool>, Func<TOk, TError>)` - Add validation
- `And<TOther>(Func<Result<TOther, TError>>)` - Combine if both succeed
- `Or<TOther>(Func<Result<TOk, TOther>>)` - Try alternative on error
- `Swap()` - Exchange success and error positions
- `TryUnwrap(out TOk?)` / `TryUnwrapError(out TError?)` - Try patterns

### Static Helpers

- `Option.Some<T>(T)` / `Option.None<T>()` - Create Options
- `Result.Ok<TOk, TError>(TOk)` / `Result.Error<TOk, TError>(TError)` - Create Results
- `Option.All(IEnumerable<Option<T>>)` - Combine Options (all must be Some)
- `Option.Any(IEnumerable<Option<T>>)` - Find first Some
- `Result.All(IEnumerable<Result<TOk, TError>>)` - Combine Results (all must succeed)
- `Result.Any(IEnumerable<Result<TOk, TError>>)` - Find first success
- `Try.Execute<TOk>(Func<TOk>)` - Convert exceptions to Results
- `Try<TException>.Execute<TOk>(Func<TOk>)` - Catch specific exception types

### Iterator Extensions

- `Enumerate<T>()` - Pair elements with indices
- `Scan<TSource, TResult>()` - Running accumulation with intermediates
- `SelectWhere<TSource, TResult>()` - Combined Select+Where using Option
- `TakeWhileInclusive<T>()` - Take while true, including first false

## Source Generators

### DiscriminatedUnion Attribute

Configure discriminated union generation:

```csharp
[DiscriminatedUnion(
    MatchOn = MatchUnionOn.Deconstruct,  // or Type, None
    GeneratePolymorphicSerialization = true,
    GeneratePrivateConstructor = true
)]
public partial record Command { /* ... */ }
```

**Options:**
- `MatchOn` - Controls how pattern matching works (Deconstruct, Type, or None)
- `GeneratePolymorphicSerialization` - Adds System.Text.Json polymorphic serialization attributes
- `GeneratePrivateConstructor` - Prevents direct instantiation of the base union type

## Real-World Examples

### API Error Handling

```csharp
public async Task<Result<User, ApiError>> GetUserAsync(int userId)
{
    return await Try<HttpRequestException>
        .Execute(() => httpClient.GetStringAsync($"/api/users/{userId}"))
        .MapError(ex => new ApiError.NetworkError(ex.Message))
        .AwaitFlatMap(json => ParseUser(json))
        .AwaitValidate(user => user.IsActive, _ => new ApiError.UserInactive())
        .AwaitMap(EnrichUserData);
}

var result = await GetUserAsync(123);
var message = result.Match(
    onOk: user => $"Welcome {user.Name}!",
    onError: error => error.Match(
        onNetworkError: msg => $"Connection failed: {msg}",
        onUserInactive: () => "User account is inactive",
        onParseError: msg => $"Invalid data: {msg}"
    )
);
```

### Safe Configuration Reading

```csharp
public Option<DatabaseConfig> LoadDatabaseConfig()
{
    return Option.FromNullable(configuration["ConnectionString"])
        .Filter(s => !string.IsNullOrWhiteSpace(s))
        .Map(connStr => new DatabaseConfig(connStr))
        .Or(() => LoadDefaultConfig());
}

// Chain multiple optional operations
var connectionString = LoadDatabaseConfig()
    .Map(config => config.ConnectionString)
    .UnwrapOr(() => "Server=localhost;Database=default");
```

## Why FunctionJunction?

**Railway-Oriented Programming Made Easy**: FunctionJunction embraces the railway-oriented programming pattern, where operations either succeed (staying on the "success track") or fail (switching to the "error track"). This makes error handling explicit, composable, and type-safe.

**Type Safety Without Exceptions**: Instead of throwing exceptions for expected failures, use `Result<TOk, TError>` to make error cases explicit in your type signatures. This forces callers to handle errors and makes your code more predictable.

**No More Null Reference Exceptions**: The `Option<T>` type eliminates null reference exceptions by making the absence of a value explicit. The compiler ensures you handle the None case before accessing the value.

**Zero Runtime Overhead**: Source generators create code at compile-time, so there's no reflection, no runtime code generation, and no performance penalty. Pattern matching on discriminated unions is as fast as a switch statement.

**Async-First Design**: Every operation that makes sense asynchronously has an `Await` variant, making it natural to write clean, composable async code without callback hell.

## Performance

- **Zero-allocation** Option and Result types (structs)
- **Compile-time** discriminated union code generation
- **Inlined** method calls for maximum performance
- **AOT-compatible** for Native AOT scenarios
- **Trim-friendly** for minimal deployment size

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change.

## License

This project is licensed under the MIT License - see the [LICENSE.txt](LICENSE.txt) file for details.

## Author

**Grant Peterson** - [dgrantpete](https://github.com/dgrantpete)

## Acknowledgments

Inspired by functional programming patterns from F#, Rust, and other ML-family languages, adapted for idiomatic C#.
